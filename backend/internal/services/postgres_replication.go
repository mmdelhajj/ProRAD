package services

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/exec"
	"time"

	"github.com/proisp/backend/internal/database"
)

// PostgresReplication handles PostgreSQL streaming replication
type PostgresReplication struct {
	mainIP       string
	dbUser       string
	dbPassword   string
	dbName       string
	dbPort       int
	replUser     string
	replPassword string
}

// NewPostgresReplication creates a new replication manager
func NewPostgresReplication(mainIP, dbUser, dbPassword, dbName string, dbPort int) *PostgresReplication {
	return &PostgresReplication{
		mainIP:       mainIP,
		dbUser:       dbUser,
		dbPassword:   dbPassword,
		dbName:       dbName,
		dbPort:       dbPort,
		replUser:     "replicator",
		replPassword: dbPassword, // Use same password for simplicity
	}
}

// SetupMainServer configures PostgreSQL on main server for replication
func (pr *PostgresReplication) SetupMainServer() error {
	log.Println("PostgresReplication: Configuring main server for replication...")

	// 1. Configure PostgreSQL for replication
	configSQL := []string{
		"ALTER SYSTEM SET wal_level = replica",
		"ALTER SYSTEM SET max_wal_senders = 10",
		"ALTER SYSTEM SET max_replication_slots = 10",
		"ALTER SYSTEM SET wal_keep_size = '1GB'",
		"ALTER SYSTEM SET hot_standby = on",
		"ALTER SYSTEM SET listen_addresses = '*'",
	}

	for _, sql := range configSQL {
		if err := database.DB.Exec(sql).Error; err != nil {
			log.Printf("PostgresReplication: Warning executing %s: %v", sql, err)
		}
	}

	// 2. Create replication user if not exists
	createUserSQL := fmt.Sprintf(`
		DO $$
		BEGIN
			IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '%s') THEN
				CREATE USER %s WITH REPLICATION ENCRYPTED PASSWORD '%s';
			END IF;
		END $$;
	`, pr.replUser, pr.replUser, pr.replPassword)

	if err := database.DB.Exec(createUserSQL).Error; err != nil {
		log.Printf("PostgresReplication: Warning creating replication user: %v", err)
	}

	// 3. Reload configuration
	if err := database.DB.Exec("SELECT pg_reload_conf()").Error; err != nil {
		log.Printf("PostgresReplication: Warning reloading config: %v", err)
	}

	log.Println("PostgresReplication: Main server configuration complete")
	log.Println("PostgresReplication: NOTE - You may need to update pg_hba.conf to allow replication connections")
	log.Println("PostgresReplication: Add this line to pg_hba.conf:")
	log.Printf("  host replication %s 0.0.0.0/0 md5", pr.replUser)

	return nil
}

// CreateReplicationSlot creates a replication slot for a secondary
func (pr *PostgresReplication) CreateReplicationSlot(slotName string) error {
	// Check if slot already exists
	var exists bool
	database.DB.Raw("SELECT EXISTS(SELECT 1 FROM pg_replication_slots WHERE slot_name = ?)", slotName).Scan(&exists)

	if exists {
		log.Printf("PostgresReplication: Replication slot %s already exists", slotName)
		return nil
	}

	// Create physical replication slot
	sql := fmt.Sprintf("SELECT pg_create_physical_replication_slot('%s')", slotName)
	if err := database.DB.Exec(sql).Error; err != nil {
		return fmt.Errorf("failed to create replication slot: %v", err)
	}

	log.Printf("PostgresReplication: Created replication slot: %s", slotName)
	return nil
}

// DropReplicationSlot removes a replication slot
func (pr *PostgresReplication) DropReplicationSlot(slotName string) error {
	sql := fmt.Sprintf("SELECT pg_drop_replication_slot('%s')", slotName)
	if err := database.DB.Exec(sql).Error; err != nil {
		log.Printf("PostgresReplication: Warning dropping slot %s: %v", slotName, err)
	}
	return nil
}

// SetupReplicaServer sets up this server as a replica
// This is a complex operation that should be run carefully
func (pr *PostgresReplication) SetupReplicaServer(slotName string) error {
	log.Println("PostgresReplication: Setting up replica server...")

	// This function generates the commands but doesn't execute them automatically
	// because stopping PostgreSQL would break the current database connection

	// Generate pg_basebackup command
	basebackupCmd := fmt.Sprintf(
		"PGPASSWORD='%s' pg_basebackup -h %s -p %d -U %s -D /var/lib/postgresql/data_new -Fp -Xs -P -R -S %s",
		pr.replPassword,
		pr.mainIP,
		pr.dbPort,
		pr.replUser,
		slotName,
	)

	// Generate setup script
	setupScript := fmt.Sprintf(`#!/bin/bash
# PostgreSQL Replica Setup Script
# Generated by ProISP Cluster Manager
# Run this script on the SECONDARY server

set -e

echo "=== ProISP PostgreSQL Replica Setup ==="
echo "Main Server: %s"
echo "Replication User: %s"
echo "Slot Name: %s"
echo ""

# Stop PostgreSQL
echo "Step 1: Stopping PostgreSQL..."
docker stop proisp-db || true

# Backup existing data (optional)
echo "Step 2: Backing up existing data..."
docker run --rm -v proisp_postgres_data:/data -v /tmp:/backup alpine tar -czf /backup/postgres_backup_$(date +%%Y%%m%%d_%%H%%M%%S).tar.gz -C /data .

# Clear data directory
echo "Step 3: Clearing data directory..."
docker run --rm -v proisp_postgres_data:/data alpine sh -c "rm -rf /data/*"

# Run pg_basebackup
echo "Step 4: Running pg_basebackup from main server..."
docker run --rm \
    -v proisp_postgres_data:/var/lib/postgresql/data \
    -e PGPASSWORD='%s' \
    postgres:16 \
    pg_basebackup -h %s -p %d -U %s -D /var/lib/postgresql/data -Fp -Xs -P -R -S %s

# Create standby.signal
echo "Step 5: Creating standby.signal..."
docker run --rm -v proisp_postgres_data:/data alpine touch /data/standby.signal

# Configure primary connection
echo "Step 6: Configuring primary connection..."
docker run --rm -v proisp_postgres_data:/data alpine sh -c "echo \"primary_conninfo = 'host=%s port=%d user=%s password=%s'\" >> /data/postgresql.auto.conf"
docker run --rm -v proisp_postgres_data:/data alpine sh -c "echo \"primary_slot_name = '%s'\" >> /data/postgresql.auto.conf"

# Fix permissions
echo "Step 7: Fixing permissions..."
docker run --rm -v proisp_postgres_data:/data alpine chown -R 999:999 /data

# Start PostgreSQL
echo "Step 8: Starting PostgreSQL..."
docker start proisp-db

echo ""
echo "=== Replica Setup Complete ==="
echo "Check replication status with: docker exec proisp-db psql -U %s -d %s -c 'SELECT * FROM pg_stat_wal_receiver'"
`,
		pr.mainIP,
		pr.replUser,
		slotName,
		pr.replPassword,
		pr.mainIP,
		pr.dbPort,
		pr.replUser,
		slotName,
		pr.mainIP,
		pr.dbPort,
		pr.replUser,
		pr.replPassword,
		slotName,
		pr.dbUser,
		pr.dbName,
	)

	// Save script to file
	scriptPath := "/tmp/setup_replica.sh"
	if err := os.WriteFile(scriptPath, []byte(setupScript), 0755); err != nil {
		return fmt.Errorf("failed to write setup script: %v", err)
	}

	log.Println("PostgresReplication: Setup script generated at /tmp/setup_replica.sh")
	log.Println("PostgresReplication: Review and run the script manually to complete replica setup")
	log.Printf("PostgresReplication: pg_basebackup command: %s", basebackupCmd)

	return nil
}

// CheckReplicationStatus checks the current replication status
func (pr *PostgresReplication) CheckReplicationStatus() (*ReplicationStatus, error) {
	status := &ReplicationStatus{
		IsReplica:   false,
		IsConnected: false,
	}

	// Check if this is a replica (standby)
	var isRecovery bool
	if err := database.DB.Raw("SELECT pg_is_in_recovery()").Scan(&isRecovery).Error; err != nil {
		return nil, fmt.Errorf("failed to check recovery status: %v", err)
	}
	status.IsReplica = isRecovery

	if isRecovery {
		// Get replica stats
		var stats struct {
			Status           string
			SenderHost       string
			SenderPort       int
			SlotName         string
			LastMsgReceiveTime time.Time
			LatestEndLsn     string
		}

		err := database.DB.Raw(`
			SELECT
				status,
				sender_host,
				sender_port,
				slot_name,
				last_msg_receipt_time,
				latest_end_lsn::text
			FROM pg_stat_wal_receiver
		`).Scan(&stats).Error

		if err == nil {
			status.IsConnected = stats.Status == "streaming"
			status.MainServerIP = stats.SenderHost
			status.MainServerPort = stats.SenderPort
			status.SlotName = stats.SlotName
			status.LastReceived = stats.LastMsgReceiveTime
			status.LatestLSN = stats.LatestEndLsn
		}

		// Calculate lag
		var lagBytes int64
		database.DB.Raw(`
			SELECT pg_wal_lsn_diff(pg_last_wal_receive_lsn(), pg_last_wal_replay_lsn())
		`).Scan(&lagBytes)
		status.LagBytes = lagBytes

	} else {
		// This is a primary - check for connected replicas
		var replicas []ReplicaInfo
		rows, err := database.DB.Raw(`
			SELECT
				client_addr,
				state,
				sent_lsn::text,
				write_lsn::text,
				flush_lsn::text,
				replay_lsn::text,
				sync_state
			FROM pg_stat_replication
		`).Rows()

		if err == nil {
			defer rows.Close()
			for rows.Next() {
				var r ReplicaInfo
				rows.Scan(&r.ClientAddr, &r.State, &r.SentLSN, &r.WriteLSN, &r.FlushLSN, &r.ReplayLSN, &r.SyncState)
				replicas = append(replicas, r)
			}
		}
		status.Replicas = replicas
	}

	return status, nil
}

// PromoteToMain promotes this replica to be the new main server
func (pr *PostgresReplication) PromoteToMain() error {
	log.Println("PostgresReplication: Promoting replica to main...")

	// Check if we're actually a replica
	var isRecovery bool
	if err := database.DB.Raw("SELECT pg_is_in_recovery()").Scan(&isRecovery).Error; err != nil {
		return fmt.Errorf("failed to check recovery status: %v", err)
	}

	if !isRecovery {
		return fmt.Errorf("this server is already a primary, cannot promote")
	}

	// Promote the replica
	if err := database.DB.Exec("SELECT pg_promote()").Error; err != nil {
		// Try file-based promotion as fallback
		log.Println("PostgresReplication: pg_promote() failed, trying file-based promotion...")

		// Create trigger file
		cmd := exec.Command("docker", "exec", "proisp-db", "touch", "/var/lib/postgresql/data/promote")
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to promote replica: %v", err)
		}
	}

	// Wait for promotion to complete
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	for {
		select {
		case <-ctx.Done():
			return fmt.Errorf("timeout waiting for promotion")
		default:
			var isRecovery bool
			database.DB.Raw("SELECT pg_is_in_recovery()").Scan(&isRecovery)
			if !isRecovery {
				log.Println("PostgresReplication: Promotion complete - this server is now the primary")
				return nil
			}
			time.Sleep(1 * time.Second)
		}
	}
}

// DemoteToReplica converts this primary to a replica (for planned switchover)
func (pr *PostgresReplication) DemoteToReplica(newMainIP string, slotName string) error {
	log.Printf("PostgresReplication: Demoting to replica of %s...", newMainIP)

	// This is a complex operation that requires:
	// 1. Stop writes on current primary
	// 2. Wait for replica to catch up
	// 3. Reconfigure as replica
	// 4. Restart PostgreSQL

	// Generate demotion script
	demoteScript := fmt.Sprintf(`#!/bin/bash
# PostgreSQL Demotion Script
# Generated by ProISP Cluster Manager

set -e

echo "=== Demoting to Replica of %s ==="

# Stop PostgreSQL
echo "Step 1: Stopping PostgreSQL..."
docker stop proisp-db

# Create standby.signal
echo "Step 2: Creating standby.signal..."
docker run --rm -v proisp_postgres_data:/data alpine touch /data/standby.signal

# Configure primary connection
echo "Step 3: Configuring primary connection..."
docker run --rm -v proisp_postgres_data:/data alpine sh -c "echo \"primary_conninfo = 'host=%s port=%d user=%s password=%s'\" >> /data/postgresql.auto.conf"
docker run --rm -v proisp_postgres_data:/data alpine sh -c "echo \"primary_slot_name = '%s'\" >> /data/postgresql.auto.conf"

# Start PostgreSQL
echo "Step 4: Starting PostgreSQL..."
docker start proisp-db

echo "=== Demotion Complete ==="
`,
		newMainIP,
		newMainIP,
		pr.dbPort,
		pr.replUser,
		pr.replPassword,
		slotName,
	)

	scriptPath := "/tmp/demote_to_replica.sh"
	if err := os.WriteFile(scriptPath, []byte(demoteScript), 0755); err != nil {
		return fmt.Errorf("failed to write demotion script: %v", err)
	}

	log.Println("PostgresReplication: Demotion script generated at /tmp/demote_to_replica.sh")
	return nil
}

// ReplicationStatus holds the current replication state
type ReplicationStatus struct {
	IsReplica      bool          `json:"is_replica"`
	IsConnected    bool          `json:"is_connected"`
	MainServerIP   string        `json:"main_server_ip,omitempty"`
	MainServerPort int           `json:"main_server_port,omitempty"`
	SlotName       string        `json:"slot_name,omitempty"`
	LastReceived   time.Time     `json:"last_received,omitempty"`
	LatestLSN      string        `json:"latest_lsn,omitempty"`
	LagBytes       int64         `json:"lag_bytes"`
	LagSeconds     int           `json:"lag_seconds"`
	Replicas       []ReplicaInfo `json:"replicas,omitempty"`
}

// ReplicaInfo contains info about a connected replica
type ReplicaInfo struct {
	ClientAddr string `json:"client_addr"`
	State      string `json:"state"`
	SentLSN    string `json:"sent_lsn"`
	WriteLSN   string `json:"write_lsn"`
	FlushLSN   string `json:"flush_lsn"`
	ReplayLSN  string `json:"replay_lsn"`
	SyncState  string `json:"sync_state"`
}

// GetReplicationLagSeconds returns the replication lag in seconds
func GetReplicationLagSeconds() int {
	if database.DB == nil {
		return -1
	}

	var isRecovery bool
	database.DB.Raw("SELECT pg_is_in_recovery()").Scan(&isRecovery)

	if !isRecovery {
		return 0 // Primary has no lag
	}

	var lagSeconds float64
	err := database.DB.Raw(`
		SELECT COALESCE(
			EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp())),
			0
		)
	`).Scan(&lagSeconds).Error

	if err != nil {
		return -1
	}

	return int(lagSeconds)
}

// IsReplicaHealthy checks if replication is working properly
func IsReplicaHealthy() bool {
	if database.DB == nil {
		return false
	}

	var isRecovery bool
	database.DB.Raw("SELECT pg_is_in_recovery()").Scan(&isRecovery)

	if !isRecovery {
		return true // Primary is always "healthy" from replication perspective
	}

	// Check if receiving WAL
	var status string
	database.DB.Raw("SELECT status FROM pg_stat_wal_receiver").Scan(&status)

	return status == "streaming"
}
